## 算法模式
1. 递归
    1. `javaScript`调用栈大小的限制
        * 递归无限制的执行下去会抛出栈溢出错误(`RangeError: Maximum call stack size exceeded`)
        ```js
        var i = 0;
        function recursiveFn() {
            i++;
            recursiveFn();
        }

        try {
            recursiveFn();
        } catch (ex) {
            console.error(ex);
        }
        ```  
    2. 斐波那契数列
        * 1和2的斐波那契数是1
        * n(n > 2)的斐波那契数是(n - 1)的斐波那契数加上(n - 2)的斐波那契数
        * 递归实现斐波那契函数
        ```js
        function fibonacci(num) {
            if (num === 1 || num === 2) {
                return 1;
            }
            return fibonacci(num - 1) + fibonacci(num - 2);
        }
        ```
        * 非递归的方式实现斐波那契函数
        ```js
        function fib(num) {
            var n1 = 1,
                n2 = 1,
                n = 1;
            for (var i = 3; i<=num; i++) {
                n = n1 + n2;
                n1 = n2;
                n2 = n;
            }
            return n;
        }
        ```
        * 得到斐波那契数列
        ```js
        var arr = [];
        function fibonacci(num) {
            if (num === 1 || num === 2) {
                arr[num - 1] = 1;
                return 1;
            }

            var x = fibonacci(num - 1) + fibonacci(num - 2);
            arr[num - 1] = x;
            return x;
        }

        console.log(fibonacci(6))
        console.log(arr)
        ``` 
3. 动态规划
    1. 楼梯问题
        ```js
        // 时间复杂度为O(n)
        // 空间复杂度为O(1)
        function getClimbingWays(n) {
            if (n < 1) {
                return 0;
            }
            if (n === 1) {
                return 1;
            }
            if (n === 2) {
                return 2;
            }

            var a = 1;
            var b = 2;
            var temp = 0;

            for (var i = 0; i <= n; i++) {
                temp = a + b;
                a = b;
                b = temp;
            }

            return temp;
        }

        console.log(getClimbingWays(10))
        ```
    2. 最少硬币找零问题
        ```js
        var minCoinChange = new MinCoinChange([1, 5, 10, 25]);
        console.log(minCoinChange.makeChange(36)); // [1, 10, 25]

        function MinCoinChange(coins) {
            var cache = {};

            this.makeChange = function (amount) {
                if (!amount) return [];
                if (cache[amount]) {
                    return cache[amount];
                }

                var min = [];
                var newMin;
                var newAmount;

                for (var i = 0; i < coins.length; i++) {
                    var coin = coins[i];
                    newAmount = amount - coin;

                    if (newAmount >= 0) {
                        newMin = this.makeChange(newAmount);
                    }

                    if (newAmount >= 0 &&
                        (newMin.length < min.length - 1 || !min.length) &&
                        (newMin.length || !newAmount)
                    ) {
                        min = [coin].concat(newMin);
                        // console.log(min, amount)
                    }
                }

                return (cache[amount] = min);
            }
        }
        ```
    3. 背包问题
4. 贪心算法
    1. 最少硬币找零问题
        ```js
        var minCoinChange = new MinCoinChange([1, 5, 10, 25]);
        console.log(minCoinChange.makeChange(36)); // [1, 10, 25]

        // 在有些情况下不会是最优的
        function MinCoinChange(coins) {
            var coins = coins;

            this.makeChange = function (amount) {
                var change = [];
                var total = 0;

                for (var i = coins.length; i >= 0; i--) {
                    var coin = coins[i];
                    while (total + coin <= amount) {
                        change.push(coin);
                        total += coin;
                    }
                }

                return change;
            }
        }
        ```
    2. 分数背包问题
        ```js
        console.log(knapSack(6, [3, 4, 5], [2, 3, 4]));

        // 背包价值
        function knapSack(capacity, values, weights) {
            var n = values.length;
            var load = 0;
            var i = 0;
            var val = 0;

            for (i = 0; i < n && load < capacity; i++) {
                if (weights[i] <= (capacity - load)) {
                    val += values[i];
                    load += weights[i];
                } else {
                    var r = (capacity - load) / weights[i];
                    val += r * values[i];
                    load += r * weights[i];
                }
            }
            return val;
        }
        ``` 