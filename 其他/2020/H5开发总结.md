# H5开发总结
## 1.盒模型
1. `box-sizing`
    * box-sizing: content-box | padding-box | border-box;
    * 默认值：content-box
2. 为了简单地规避元素盒模型大小可变性造成的网页排版问题，一般我们会在样式重置的规则中，将盒模型设置成 border-box
    ```css
    *, *:before, *:after {
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
    }
    ```
## 2.响应式页面
1. 添加 `viewport meta` 标签
    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1">
    ```
2. 使用 `Media Queries`

|name|des|
|:----|:----|
|min-width|	当视窗宽度大于或等于指定值时，@media 规则下的样式将被应用|
|max-width|	当视窗宽度小于或等于指定值时，@media 规则下的样式将被应用|
|min-height|	当视窗高度大于或等于指定值时，@media 规则下的样式将被应用|
|max-height|	当视窗高度小于或等于指定值时，@media 规则下的样式将被应用|
|orientation=portrait|	当视窗高度大于或等于宽度时，@media 规则下的样式将被应用|
|orientation=landscape|	当视窗宽度大于高度时，@media 规则下的样式将被应用|
3. `Media Queries`2种用法
    1. 使用 link 标签，根据指定特性引入特定的外部样式文件
        ```html
        <link rel="stylesheet" media="(max-width: 640px)" href="max-640px.css">
        ```
    2. 直接在 style 标签或 样式文件内使用 @media 规则
        ```css
        @media (max-width: 640px) {
            /*当视窗宽度小于或等于 640px 时，这里的样式将生效*/
        }
        ```
4. 样式断点(依据目标设备的分辨率，制定一套合适的样式断点，并为不同的断点定制必要的 CSS 样式) 

|name|des|
|:----|:----|
|mobile|移动设备断点，视窗宽度 ≤ 768 px|
|tablet|平板电脑设备断点，视窗宽度 ≥ 769 px|
|desktop|桌面电脑断点，视窗宽度 ≥ 1024 px|
|widescreen|宽屏电脑断点，视窗宽度 ≥ 1216 px|
|fullhd|高清宽屏电脑断点，视窗宽度 ≥ 1408 px|

```css
@media (min-width: 769px) {
  /* tablet 及以上的设备，页面背景色设置为红色 */
  body {
    background-color: red;
  }
}
```
## 3.使用Viewport单位及rem
1. 利用 Sass 函数将设计稿元素尺寸的像素单位转换为 vw 单位
```scss
/* iPhone 6尺寸作为设计稿基准 */
/* iPhone6尺寸作为设计稿基准$vw_base  */
$vw_base: 375;
@function vw($px) {
    @return ($px / $vm_base) * 100vw;
}
```
```scss
.mod_nav {
    background-color: #fff;
    &_list {
        display: flex;
        padding: vw(15) vw(10) vw(10); // 内间距
        &_item {
            flex: 1;
            text-align: center;
            font-size: vw(10); // 字体大小
            &_logo {
                display: block;
                margin: 0 auto;
                width: vw(40); // 宽度
                height: vw(40); // 高度
                img {
                    display: block;
                    margin: 0 auto;
                    max-width: 100%;
                }
            }
            &_name {
                margin-top: vw(2);
            }
        }
    }
}
```
2. 1 物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现
```scss
.mod_grid {
    position: relative;
    &::after {
        // 实现1物理像素的下边框线
        content: '';
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background-color: #ddd;
        height: 1px;
        left: 0;
        right: 0;
        top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) {
            -webkit-transform: scaleY(0.5);
            -webkit-transform-origin: 50% 0%;
        }
    }
}
```
3. 对于需要保持高宽比的图，应改用 padding-top 实现
```scss
.mod_banner {
    position: relative;
    // 使用padding-top 实现宽高比为 100:750 的图片区域
    padding-top: percentage(100/750);
    height: 0;
    overflow: hidden;
    img {
        width: 100%;
        height: auto;
        position: absolute;
        left: 0;
        top: 0; 
    }
}
```
## 4.vw 搭配 rem，寻找最优解
1. 给根元素的字体大小设置随着视窗变化而变化的 vw 单位，这样就可以实现动态改变其大小
2. 其他元素的文本字号大小、布局高宽、间距、留白都使用 rem 单位
3. 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度，实现布局宽度的最大最小限制
```scss
// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) {
     @return ($px / $vw_fontsize ) * 1rem;
}
// 根元素大小使用 vw 单位
$vw_design: 750;
html {
    font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) {
        font-size: 64px;
    }
    @media screen and (min-width: 540px) {
        font-size: 108px;
    }
}
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body {
    max-width: 540px;
    min-width: 320px;
}
```
## 5.使用transitionend，监听transiont结束回调
```js
document.getElementById("myDIV").addEventListener("transitionend", myFunction);
``` 
## 6.css3 Transition
1. 支持有限的 CSS 属性
2. 隐式过渡`（implicit transitions）`
3. 一次性、不可暂停或反转
4. 常常利用 `transition` 来做那些轻量的、修饰性的动效，用于增强用户在网页上操作时得到的反馈
5. 使用`transitionend`，监听`transiont`结束回调
```js
document.getElementById("myDIV").addEventListener("transitionend", myFunction);
```  
```css
.transition-target {
    transition: <property> <duration> <timing-function> <delay>;
}
```

## 7.css3 Animation
1. `@keyframes` 用来定义一个动画的具体状态内容
2. `animation`用来定义一个元素执行某个动画时的相关动画设定, 属性如下
    * `animation-name`
        * 指定元素用什么动画？
    * `animation-duration`
        * 动画的持续时间是多少？
    * `animation-timing-function`
        * 浏览器用什么样的时间轴函数来执行该动画？
    * `animation-delay`
        * 是否需要延时执行该动画？
        * 可使用负数，提前开始执行动画
    * `animation-iteration-count`
        * 动画循环执行的次数是多少？
        * 使用`infinite`执行无限次
    * `animation-direction`
        * 动画执行的方向是什么？
        * `reverse`,动画反向播放。
        * `alternate`,动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。
        * `alternate-reverse`,动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。
    * `animation-fill-mode`
        * 动画填充模式是什么？
        * `none`, 默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。
        * `forwards`, 在动画结束后（由 animation-iteration-count 决定），动画将应用该属性值。
        * `backwards`, 动画将应用在 animation-delay 定义期间启动动画的第一次迭代的关键帧中定义的属性值。
        * `both`, 相当于同时配置了backwards和forwards，意味着在动画等待和动画结束状态，元素将分别应用动画第一帧和最后一帧的样式。
    * `animation-play-state`
        * 动画执行状态是运行还是暂停？
## 8.3D动画
```html
<div class="page">
    <div class="page_cover">Cover</div>
    <div class="page_back">1</div>
</div>
```
```css
.page {
    position: absolute;
    top: 0;
    left: 50%;
    width: 200px;
    height: 250px;
    transform-origin: left center;
    transform-style: preserve-3d;
    transition: all ease 1s;
    transform: rotateY(-180deg);
}

.page_cover {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    line-height: 250px;
    text-align: center;
    color: #FFF;
    font-size: 24px;
    backface-visibility: hidden;
    background: #000;
}

.page_back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    line-height: 250px;
    text-align: center;
    color: #FFF;
    font-size: 24px;
    backface-visibility: hidden;
    background: red;
    transform: rotateY(180deg);
}
```
## 9.逐帧动画
1. 直接使用 GIF
2. 使用 JavaScript 控制动画播放
    * 将动画帧合并成雪碧图，放到 background-image 中，通过 JavaScript 改变 background-position 的值来实现动画的播放。
    * 使用 JavaScript 实现逐帧动画，兼容性佳，且交互灵活。
3. 使用 Canvas 及相关库
    * 将动画帧绘制到 Canvas 上，通过不断地重绘即可实现逐帧动画。`CreateJS`、`Pixi.js` 等库都提供了成熟的方案。
    * 使用 Canvas 可以利用硬件加速，功能强大，操作灵活，有丰富的类库，但学习成本较高，且老式浏览器不兼容 Canvas。
4. 使用 CSS3 阶梯函数 steps(number_of_steps, direction)
    * CSS3 使用 animation-timing-function 的阶梯函数 steps(number_of_steps, direction) 来实现逐帧动画。
    * `steps(number_of_steps, direction)`
        * 第一个参数指定了函数中的间隔数量（必须是正整数）
        * 第二个参数可选，指定在每个间隔的起点或是终点发生阶跃变化，接受 start 和 end 两个值，默认为 end
    * example
        ```css
        .page_key {
            position: absolute;
            left: 20px;
            top: 20px;
            width: 200px;
            height: 206px;
            background-image: url("../img/p8.png");
        }
        ```
        ```css
        /* 写法一 2个关键帧的间隔为1*/
        .page_key {
            animation: p8 steps(1,end) 1.5s infinite;
        }
        @keyframes p8 {
            0% {background-position: 0 0;}
            33.33333% {background-position: 0 -206px;}
            66.66667% {background-position: 0 -412px;}
            100% {background-position: 0 -618px;}
        }
        ```
        ```css
        /* 写法二 */
        .page_key{
            animation: p8 steps(3,end) 1.5s infinite;
        }
        @keyframes p8 {
            100% {background-position: 0 -618px;}
        }
        ```
    * `·step-start` 与 `step-end`
        * `step-start` 等同于 `steps(1, start)`：动画执行时以开始端点为开始。
        * `step-end` 等同于 `steps(1, end)`：动画执行时以结尾端点为开始。
    * 使用 Sass 完成动画帧的计算
        ```css
        /* 写法一 */
        @mixin frame($frameNum, $frameHeight) {
            @for $i from 0 through $frameNum {
                #{100/$frameNum*$i}% {background-position: 0 #{-$i*$frameHeight}px;}
            }
        }
        /* 写法二 */
        @mixin frame($frameNum, $frameHeight) {
            100% {background-position: 0 #{-$frameNum*$frameHeight}px;}
        }

        @keyframes p8 {
            @include frame($frameNum: 3, $frameHeight: 206)
        }
        ```
    * 逐帧动画部分，使用 px 做单位，再结合 JavaScript 对动画部分使用 scale 进行缩放, 防止rem的计算误差，动画抖动
    * CSS3 实现的逐帧动画，如果它的帧数较多或尺寸较大时，移动端可能会存在渲染性能问题，此时建议改用 Canvas 实现。如 CreateJS、Pixi.js 等。
